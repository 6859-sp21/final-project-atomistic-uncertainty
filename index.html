
<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>
<script src=style.css></script>

<head> 
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div>
    <div id="sections">
    <section id ="section1"  class="step">
        <div class="title">Differentiable sampling of molecular geometries with uncertainty-based adversarial attacks</div>
    </section>
    <section id ="section2" class="step">
        section 2
    </section>
    <section id ="section3" class="step">
        section 3
    </section>
    <section id ="section4" class="step">
        section 4
    </section>
    <section id ="section5" class="step">
        section 5
    </section>

    </div>


    <div id='vis'>
    <svg id='svg0' class = "visuals"></svg>
    <svg id='svg1' class = "visuals"></svg>
    <svg id='svg2' class = "visuals"></svg>
    </div>

</div>
</body>




<script>

const value = (x, y) => Math.sin(x + y) * Math.sin(x - y); 
const scale = 1/80;
const height = 600;
const width = 1000;

let alldata = [grid(0)];
let allpoints = [{id:0, x: 500, y: 140},{id:1, x: 600, y: 240}, {id:2, x: 184, y: 340}, {id:3, x: 700, y: 540}];
let iteration = [{value:1}]


const thresholds = [-1.2, -1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8];
const color = d3.scaleSequential([-1, 1], d3.interpolateSpectral);
const path = d3.geoPath();
const contours = d3.contours()
    .size([width, height])

let angle = 0;
let count = 1;

//Initializing visualization
const svg0 = d3.select('#svg0')
    .attr('width', width)
    .attr('height', height)
svg0.append('text')
    .attr('x', 100)
    .attr('y', 300)
    .attr('fill', 'black')
    .attr('font-family', 'Helvetica Neue, Arial')
    .attr('font-size', 80)
    .text("This is title");



const svg1 = d3.select('#svg1')
.attr('width', width)
.attr('height', height);
let interval = setInterval(function() {
    updateData(grid(angle), count);
    updatePoint();
    renderContour(0);
    count = (count+1) % 10;
    angle = (angle + 15) % 150;
}, 750);


const svg2 = d3.select('#svg2')
    .attr('width', width)
    .attr('height', height)
svg2.append('text')
    .attr('x', 100)
    .attr('y', 300)
    .attr('fill', 'black')
    .attr('font-family', 'Helvetica Neue, Arial')
    .attr('font-size', 80)
    .text("This is section 3");



// Scrolling functions  
let sections = d3.selectAll('.step');
let sectionPositions = [];
let startPos;
sections.each(function(d,i) {
    let top = this.getBoundingClientRect().top;
        if(i === 0) {
            startPos = top;
        }
    sectionPositions.push(top - startPos);
    });
console.log(sectionPositions)

let activateFunctions = [];
activateFunctions[0] = showTitle;
activateFunctions[1] = showContour;
activateFunctions[2] = showEnd;

let scroll = scroller();
scroll(d3.selectAll('.step'));
scroll.on('active', function (index) {
     console.log(index);
     d3.selectAll('.step')
       .style('opacity', function (d, i) { return i === index ? 1 : 0.1; });
    activateFunctions[index]();
   });







function grid (shift = 0) {
  const x0 = 0, x1 = width;
  const y0 = 0, y1 = height;
  const n = Math.ceil((x1 - x0));
  const m = Math.ceil((y1 - y0));
  const grid = new Array(n * m);
  for (let j = 0; j < m; ++j) {
    for (let i = 0; i < n; ++i) {
      grid[j * n + i] = value(i * scale + shift, j * scale );
    }
  }
  return {id: shift, value: grid};
}

function updateData(newgrid, count){
    alldata[0] = newgrid;
    iteration[0] = {value: count};
}

function updatePoint(){

    for (i = 0; i < 4; i++) {
        let x = Math.floor(Math.random() * 1000);
        let y = Math.floor(Math.random() * 600);
        let id = Math.floor(Math.random() * 100);

        allpoints[i] = {id:id, x:x, y:y};

    }


}





function scroller() {
//   let container = d3.select('body');
  // event dispatcher
  let dispatch = d3.dispatch('active', 'progress');

  // d3 selection of all the
  // text sections that will
  // be scrolled through
  let sections = null;

  // array that will hold the
  // y coordinate of each section
  // that is scrolled through
//   let sectionPositions = [];
  let currentIndex = -1;
  // y coordinate of
//   let containerStart = 0;

  /**
   * scroll - constructor function.
   * Sets up scroller to monitor
   * scrolling of els selection.
   *
   * @param els - d3 selection of
   *  elements that will be scrolled
   *  through by user.
   */
  function scroll(els) {
    sections = els;

    // when window is scrolled call
    // position. When it is resized
    // call resize.
    d3.select(window)
      .on('scroll.scroller', position);

    let timer = d3.timer(function () {
      position();
      timer.stop();
    });
  }


  /**
   * position - get current users position.
   * if user has scrolled to new section,
   * dispatch active event with new section
   * index.
   *
   */
  function position() {
    let pos = window.pageYOffset - 10;
    let sectionIndex = d3.bisect(sectionPositions, pos);
    sectionIndex = Math.min(sections.size() - 1, sectionIndex);

    if (currentIndex !== sectionIndex) {
      dispatch.call('active', this, sectionIndex);
      currentIndex = sectionIndex;
    }

    let prevIndex = Math.max(sectionIndex - 1, 0);
    let prevTop = sectionPositions[prevIndex];
    let progress = (pos - prevTop) / (sectionPositions[sectionIndex] - prevTop);
    dispatch.call('progress', this, currentIndex, progress);
    // console.log(pos, currentIndex);
  }

  /**
   * container - get/set the parent element
   * of the sections. Useful for if the
   * scrolling doesn't start at the very top
   * of the page.
   *
   * @param value - the new container value
   */
//   scroll.container = function (value) {
//     if (arguments.length === 0) {
//       return container;
//     }
//     container = value;
//     return scroll;
//   };

  // @v4 There is now no d3.rebind, so this implements
  // a .on method to pass in a callback to the dispatcher.
  scroll.on = function (action, callback) {
    dispatch.on(action, callback);
  };

  return scroll;
}




function renderContour(i = 1){
    let g = svg1
    .selectAll('g')
    .data(alldata, data => data.id)
    .join('g')
        .attr("stroke", "white")
        .attr("stroke-width", 0.03);
    
    for (const threshold of thresholds) {
        g.append("path")
            .attr("d", path(contours.contour(alldata[0].value, threshold)))
            .attr("fill", color(threshold))
            .attr("opacity", d => i == 1 ? 1 : 0);
        }
    
    let circles = svg1
    .selectAll("circle")
    .data(allpoints, data => data.id)
    .join("circle")
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr("r", 10)
        .attr("stroke", "none")
        .attr("fill", "red")
        .attr("opacity", d => i == 1 ? 1 : 0); 
    d3.selectAll("circle").each(function() {  
    this.parentNode.appendChild(this); 
    });

    let label = svg1
    .selectAll('text')
    .data(iteration, data => data.value)
    .join('text')
        .attr('x', 0)
        .attr('y', height/20)
        .attr('fill', 'black')
        .attr('font-family', 'Helvetica Neue, Arial')
        .attr('font-size', 40)
        .attr("opacity", d => i == 1 ? 1 : 0)
        .text(d => "Iteration " + d. value);
    
}



function showTitle() {
    d3.selectAll(".visuals")
    .transition()
    .duration(0)
    .attr("opacity", 0);
  
    d3.select('#svg0')
    .transition()
    .duration(600)
    .attr("opacity", 1);
}




function showContour() {
    d3.selectAll(".visuals")
    .transition()
    .duration(0)
    .attr("opacity", 0);


    d3.select('#svg1')
    .transition()
    .duration(600)
    .attr("opacity", 1);

    clearInterval(interval);
    
    interval = setInterval(function() {
    updateData(grid(angle), count);
    updatePoint();
    renderContour(1);
    count = (count+1) % 10;
    angle = (angle + 15) % 150;
    }, 750);
}


function showEnd() {
    d3.selectAll(".visuals")
    .transition()
    .duration(0)
    .attr("opacity", 0);
  
    d3.select('#svg2')
    .transition()
    .duration(600)
    .attr("opacity", 1);
}








</script>


